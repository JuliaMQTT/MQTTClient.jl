var documenterSearchIndex = {"docs":
[{"location":"api/client/","page":"Client","title":"Client","text":"Client\nMQTTConnection\nIOConnection\nMQTTClient.Message\nUser","category":"page"},{"location":"api/client/#MQTTClient.Client","page":"Client","title":"MQTTClient.Client","text":"Client\n\nThe MQTT client in Julia facilitates communication between a device and an MQTT broker over a network.  It manages connections, message handling, and maintains the state of communication.  The client operates through three main loops: the read loop listens for incoming messages from the broker and processes them using designated handlers;  the write loop sends packets to the broker from a queue, ensuring thread safety with a socket lock;  and the keep-alive loop periodically sends ping requests to the broker to maintain the connection and detect disconnections.  This client uses atomic operations to ensure thread safety for shared variables and supports asynchronous task management for efficient, non-blocking operations.\n\nFields\n\nstate::UInt8: client state.\non_msg::TrieNode: A trie mapping topics to callback functions.\nkeep_alive::UInt16: The keep-alive time in seconds.\nlast_id::UInt16: The last packet identifier used.\nin_flight::Dict{UInt16, Future}: A dictionary mapping packet identifiers to futures.\nwrite_packets::AbstractChannel: A channel for writing packets.\nsocket: The socket used for communication with the broker.\nsocket_lock: A lock for synchronizing access to the socket.\nping_timeout::UInt64: The ping timeout in seconds.\nping_outstanding::Atomic{UInt8}: An atomic counter for the number of outstanding ping requests.\nlast_sent::Atomic{Float64}: An atomic float representing the timestamp of the last sent packet.\nlast_received::Atomic{Float64}: An atomic float representing the timestamp of the last received packet.\n\nConstructor\n\nClient(ping_timeout::UInt64=UInt64(60)) constructs a new Client object with the specified ping timeout (default: 60 seconds).\n\n\n\n\n\n","category":"type"},{"location":"api/client/#MQTTClient.MQTTConnection","page":"Client","title":"MQTTClient.MQTTConnection","text":"MQTTConnection{T <: AbstractIOConnection}\n\nThe MQTTConnection struct in Julia encapsulates the configuration and connection details required for an MQTT client to connect to an MQTT broker.  This struct supports two types of connection protocols: TCP and Unix Domain Sockets (UDS), both of which are subtypes of AbstractIOConnection.  The struct includes fields for protocol type, keep-alive interval, client ID, user credentials, a will message (a message that is sent by the broker if the client disconnects unexpectedly),  and a flag indicating whether the session is clean (i.e., no persistent session state).  The MQTTConnection constructor allows for flexible instantiation with default or specified values for each field,  enabling easy setup of connection parameters tailored to the specific requirements of the MQTT client and broker interaction.\n\nFields\n\nprotocol::T: The underlying IO connection.\nkeep_alive::Int64: The keep-alive time in seconds.\nclient_id::String: The client identifier.\nuser::User: The user credentials.\nwill::Message: The last will and testament message.\nclean_session::Bool: Whether to start a clean session.\n\nConstructors\n\nMQTTConnection(protocol::T;         keep_alive::Int64=32,         client_id::String=randstring(8),         user::User=User(\"\", \"\"),         will::Message=Message(false, 0x00, false, \"\", UInt8[]),         clean_session::Bool=true) where T <: AbstractIOConnection constructs a new MQTTConnection object with the specified protocol and optional keyword arguments.\n\nMQTTConnection(protocol::T,         keep_alive::Int64,         client_id::String,         user::User,         will::Message,         clean_session::Bool) where T <: AbstractIOConnection constructs a new MQTTConnection object with the specified arguments.\n\nExample using TCP protocol with default and custom values\n\ntcpconnection = MQTTConnection(     TCP(Sockets.localhost, 1883);       # Using TCP with localhost and port 1883     keepalive=60,                      # Custom keep-alive interval of 60 seconds     clientid=\"mymqttclient\",         # Custom client ID     user=User(\"username\", \"password\"),  # Custom user credentials     will=Message(false, 0x01, false, \"last/will/topic\", UInt8[]),  # Custom will message     cleansession=true                  # Default clean session flag )\n\nExample using UDS protocol with all custom values\n\nudsconnectionfull = MQTTConnection(     UDS(\"/var/run/mqtt.sock\"),          # Using UDS with specified socket path     45,                                 # Custom keep-alive interval of 45 seconds     \"another_client\",                   # Custom client ID     User(\"user\", \"pass\"),               # Custom user credentials     Message(true, 0x00, true, \"will/topic\", UInt8[1, 2, 3]),  # Custom will message     false                               # Custom clean session flag )\n\n\n\n\n\n","category":"type"},{"location":"api/client/#MQTTClient.IOConnection","page":"Client","title":"MQTTClient.IOConnection","text":"IOConnection(ip::IPAddr, port::Int64)\n\nConstructs a new TCP object with the specified IP address and port number.\n\nArguments\n\nip::IPAddr: The IP address of the remote host.\nport::Int64: The port number on the remote host.\n\nReturns\n\nTCP: A new TCP object.\n\n\n\nIOConnection(ip::String, port::Int64)\n\nConstructs a new TCP object with the specified IP address and port number.\n\nArguments\n\nip::String: The IP address of the remote host as a string.\nport::Int64: The port number on the remote host.\n\nReturns\n\nTCP: A new TCP object.\n\n\n\nIOConnection(path::AbstractString)\n\nConstructs a new UDS object with the specified file system path.\n\nArguments\n\npath::AbstractString: The file system path of the socket.\n\nReturns\n\nUDS: A new UDS object.\n\n\n\n\n\n","category":"function"},{"location":"api/client/#MQTTClient.Message","page":"Client","title":"MQTTClient.Message","text":"Message\n\nA composite type representing a message.\n\nFields\n\ndup::Bool: a boolean indicating whether the message is a duplicate.\nqos::UInt8: an 8-bit unsigned integer representing the quality of service.\nretain::Bool: a boolean indicating whether the message should be retained.\ntopic::String: a string representing the topic.\npayload::Array{UInt8}: an array of 8-bit unsigned integers representing the payload.\n\nConstructors\n\nMessage(qos::QOS, topic::String, payload...): constructs a new message with default values for dup and retain.\nMessage(dup::Bool, qos::QOS, retain::Bool, topic::String, payload...): constructs a new message with all fields specified.\nMessage(dup::Bool, qos::UInt8, retain::Bool, topic::String, payload...): constructs a new message with all fields specified.\n\n\n\n\n\n","category":"type"},{"location":"api/client/#MQTTClient.User","page":"Client","title":"MQTTClient.User","text":"User(name::String, password::String)\n\nA struct that represents a user with a name and password.\n\nExamples\n\nuser = User(\"John\", \"password\")\n\nUser(\"John\", \"password\")\n\n\n\n\n\n","category":"type"},{"location":"client/#Client-struct","page":"MQTT Client","title":"Client struct","text":"","category":"section"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"The client struct is used to store state for an MQTT connection. All callbacks, apart from on_message, can't be set through the constructor and have to be set manually after instantiating the Client struct.","category":"page"},{"location":"client/#Constructors","page":"MQTT Client","title":"Constructors","text":"","category":"section"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"Client()","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"Specify a custom ping_timeout of 600 seconds","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"Client(600)","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"Use the wrapping function to get the client and the connection metadata struct. This generates a client and a connection object that can be used for making connections. The connection object stores information about how to connect the client to the broker.","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"Passing a ip and a port will be infered as a TCP connection.","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"client, connection = MakeConnection(\"localhost\", 1883)","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"Passing a single path string will be infered as a UDS connection.","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"client, connection = MakeConnection(\"/tmp/mqtt.sock\")","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"Additional information can be specified when the client and connection objects are constructed.","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"client, connection = MakeConnection(\"/tmp/mqtt.sock\", keep_alive=60, client_id=\"TestClient\", user=User(\"name\", \"pw\"), will=Message(QOS_2, \"TestClient/will\", \"payload\", more_payload_data))","category":"page"},{"location":"client/#Message-struct","page":"MQTT Client","title":"Message struct","text":"","category":"section"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"The Message struct is the data structure for generic MQTT messages. This is mostly used internally but is exposed to the user in some cases for easier to read arguments (Passing a \"will\" to the connect method uses the Message struct for example).","category":"page"},{"location":"client/#Constructors-2","page":"MQTT Client","title":"Constructors","text":"","category":"section"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"This is a reduced constructor meant for messages that can't be duplicate or retained (like the \"will\"). This message constructor should be in most cases! The dup and retained flag are false by default.","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"function Message(qos::QOS, topic::String, payload...)","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"This is the full Message constructor. It has all possible fields.","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"function Message(dup::Bool, qos::QOS, retain::Bool, topic::String, payload...)","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"This constructor is mostly for internal use. It uses the UInt8 equivalent of the QOS enum for easier processing.","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"function Message(dup::Bool, qos::UInt8, retain::Bool, topic::String, payload...)","category":"page"},{"location":"getting-started/#MQTTClient","page":"Getting Started","title":"MQTTClient","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Documentation for MQTTClient.","category":"page"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Pkg.add(\"MQTTClient\")","category":"page"},{"location":"getting-started/#Testing","page":"Getting Started","title":"Testing","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Pkg.test(\"MQTTClient\")","category":"page"},{"location":"getting-started/#Usage","page":"Getting Started","title":"Usage","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Import the library with the using keyword.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Samples are available in the examples directory.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using MQTTClient","category":"page"},{"location":"getting-started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"To use this library you need to follow at least these steps:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Create an MQTTConnection struct for a given broker and protocol.\nCreate an instance of the Client struct.\nCall the connect method with your Client and MQTTConnection instance.\nExchange data with the broker through publish, subscribe and unsubscribe. When subscribing, pass your on_msg function for that topic.\nDisconnect from the broker. (Not strictly necessary, if you don't want to resume the session but considered good form and less likely to crash).","category":"page"},{"location":"getting-started/#Basic-example","page":"Getting Started","title":"Basic example","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Refer to the corresponding method documentation to find more options.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using MQTTClient\nbroker = \"test.mosquitto.org\"\n\n#Define the callback for receiving messages.\nfunction on_msg(topic, payload)\n    @info(\"Received message topic: [\", topic, \"] payload: [\", String(payload), \"]\")\nend\n\n#Instantiate a client and connection.\nclient, connection = MakeConnection(broker, 1883)\nconnect(client, connection)\n#Set retain to true so we can receive a message from the broker once we subscribe\n#to this topic.\npublish(client, \"jlExample\", \"Hello World!\", retain=true)\n#Subscribe to the topic we sent a retained message to.\nsubscribe(client, \"jlExample\", on_msg, qos=QOS_1)\n#Unsubscribe from the topic\nunsubscribe(client, \"jlExample\")\n#Disconnect from the broker. Not strictly needed as the broker will also\n#disconnect us if the socket is closed. But this is considered good form\n#and needed if you want to resume this session later.\ndisconnect(client)","category":"page"},{"location":"getting-started/#Internal-workings","page":"Getting Started","title":"Internal workings","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"It isn't necessary to read this section if you just want to use this library but it might give additional insight into how everything works.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The Client instance has a Channel, called write_packets, to keep track of outbound messages that still need to be sent. Julia channels are basically just blocking queues so they have exactly the behavior we want.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For storing messages that are awaiting acknowledgment, Client has a Dict, mapping message ids to Future instances. These futures get completed once the message has been completely acknowledged. There might then be information in the Future relevant to the specific message.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Once the connect method is called on a Client, relevant fields are initialized and the julia connect method is called to get a connected socket. Then two background tasks are started that perpetually check for messages to send and receive. If keep_alive is non-zero another tasks get started that handles sending the keep alive and verifying the pingresp arrived in time.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"TODO explain read and write loop a bit","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"TODO explain topic trie structure","category":"page"},{"location":"interfaces/#Connect","page":"MQTT Interface Functions","title":"Connect","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"MQTT v3.1.1 Doc","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Connects the Client instance to the specified broker. There is a synchronous and an asynchronous version available. Both versions take the same arguments.","category":"page"},{"location":"interfaces/#Arguments","page":"MQTT Interface Functions","title":"Arguments","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Required arguments:","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"client::Client: The client to connect to the broker.\nconnection::MQTTConnection: The information for how the client connects to the broker.","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"use MakeConnection to get the client and the connection objects. ","category":"page"},{"location":"interfaces/#Call-example","page":"MQTT Interface Functions","title":"Call example","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"connect(client, connection)","category":"page"},{"location":"interfaces/#Synchronous-connect","page":"MQTT Interface Functions","title":"Synchronous connect","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method waits until the client is connected to the broker.","category":"page"},{"location":"interfaces/#Asynchronous-connect","page":"MQTT Interface Functions","title":"Asynchronous connect","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method doesn't wait and returns a Future object. You may wait on this object with the fetch method. This future completes once the client is fully connected.","category":"page"},{"location":"interfaces/#Publish","page":"MQTT Interface Functions","title":"Publish","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"MQTT v3.1.1 Doc","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Publishes a message to the broker connected to the Client instance provided as a parameter. There is a synchronous and an asynchronous version available. Both versions take the same arguments.","category":"page"},{"location":"interfaces/#Arguments-2","page":"MQTT Interface Functions","title":"Arguments","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Required arguments:","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"client::Client: The client to send the message over.\ntopic::String: The topic to publish on. Normal rules for publish topics apply so \"/ are allowed but no wildcards.\npayload::Any...: Can be several parameters with potentially different types. Can also be empty.","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Optional arguments:","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"dup::Bool: Tells the broker that the message is a duplicate. This should not be used under normal circumstances as the library handles this. ; default = false\nqos::QOS: The MQTT quality of service to use for the message. This has to be a QOS constant (QOS0, QOS1, QOS2). ; *default = QOS0*\nretain::Bool: Whether or not the message should be retained by the broker. This means the broker sends it to all clients who subscribe to this topic ; default = false","category":"page"},{"location":"interfaces/#Call-example-2","page":"MQTT Interface Functions","title":"Call example","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"These are valid payload... examples.","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"publish(client, \"hello\" \"world\")\npublish(client, \"foo/bar\", \"hello world\")","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This is a valid use of the optional arguments.","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"publish(client, \"foo/bar\", \"hello world\", qos=QOS_1, retain=true)","category":"page"},{"location":"interfaces/#Synchronous-publish","page":"MQTT Interface Functions","title":"Synchronous publish","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method waits until the publish message has been processed completely and successfully. So in case of QOS 2 it waits until the PUBCOMP has been received.","category":"page"},{"location":"interfaces/#Asynchronous-publish","page":"MQTT Interface Functions","title":"Asynchronous publish","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method doesn't wait and returns a Future object. You may choose to wait on this object. This future completes once the publish message has been processed completely and successfully. So in case of QOS 2 it waits until the PUBCOMP has been received.","category":"page"},{"location":"interfaces/#Subscribe","page":"MQTT Interface Functions","title":"Subscribe","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"MQTT v3.1.1 Doc","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Subscribes the Client instance, provided as a parameter, to the specified topics. There is a synchronous and an asynchronous version available. Both versions take the same arguments. ","category":"page"},{"location":"interfaces/#Arguments-3","page":"MQTT Interface Functions","title":"Arguments","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Required arguments:","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"client::Client: The connected client to subscribe on. TODO phrasing?\ntopic::String: The name of the topic.\non_msg::Function: the callback function for that topic.\nqos::QOS: the named argument to set the QOS, defaults to QOS_0.","category":"page"},{"location":"interfaces/#Call-example-3","page":"MQTT Interface Functions","title":"Call example","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This example subscribes to the topic \"test\" with QOS_2.","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"cb(topic, payload) = println(\"[$topic] $(String(payload))\")\nsubscribe(client, \"test\", cb, qos=QOS_2))","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"While a lambda function can be used, it can help to define the callback function.","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"cb(topic, payload) = println(\"[$topic] $(String(payload))\")\nsubscribe(client, \"foo/bar\", cb, qos=QOS_2)\nsubscribe(client, \"foo/baz\", ((args...) -> nothing), qos=QOS_2)","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"julia> client.on_msg\nfoo/bar: cb\nfoo/baz: #15","category":"page"},{"location":"interfaces/#Synchronous-subscribe","page":"MQTT Interface Functions","title":"Synchronous subscribe","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method waits until the subscribe message has been successfully sent and acknowledged.","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"subscribe(c, \"test\", on_msg, qos=QOS_2))","category":"page"},{"location":"interfaces/#Asynchronous-subscribe","page":"MQTT Interface Functions","title":"Asynchronous subscribe","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method doesn't wait and returns a Future object. You may choose to wait on this object. This future completes once the subscribe message has been successfully sent and acknowledged.","category":"page"},{"location":"interfaces/#Unsubscribe","page":"MQTT Interface Functions","title":"Unsubscribe","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"MQTT v3.1.1 Doc","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method unsubscribes the Client from the specified topics. There is a synchronous and an asynchronous version available. Both versions take the same arguments.","category":"page"},{"location":"interfaces/#Arguments-4","page":"MQTT Interface Functions","title":"Arguments","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Required arguments:","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"client::Client: The connected client to unsubscribe from the topics.\ntopics::String...: The Tuple of topics to unsubscribe from.","category":"page"},{"location":"interfaces/#Example-call","page":"MQTT Interface Functions","title":"Example call","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"unsubscribe(client, \"test\")","category":"page"},{"location":"interfaces/#Synchronous-unsubscribe","page":"MQTT Interface Functions","title":"Synchronous unsubscribe","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method waits until the unsubscribe method has been sent and acknowledged.","category":"page"},{"location":"interfaces/#Asynchronous-unsubscribe","page":"MQTT Interface Functions","title":"Asynchronous unsubscribe","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method doesn't wait and returns a Future object. You may wait on this object with the fetch method. This future completes once the unsubscribe message has been sent and acknowledged.","category":"page"},{"location":"interfaces/#Disconnect","page":"MQTT Interface Functions","title":"Disconnect","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"MQTT v3.1.1 Doc","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Disconnects the Client instance gracefully, shuts down the background tasks and stores session state. There is only a synchronous version available.","category":"page"},{"location":"interfaces/#Arguments-5","page":"MQTT Interface Functions","title":"Arguments","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Required arguments:","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"client::Client: The client to disconnect.","category":"page"},{"location":"interfaces/#Example-call-2","page":"MQTT Interface Functions","title":"Example call","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"disconnect(client)","category":"page"},{"location":"api/interface/","page":"Interfacing Functions","title":"Interfacing Functions","text":"MakeConnection\nconnect_async\nconnect\ndisconnect\nsubscribe_async\nsubscribe\nunsubscribe_async\nunsubscribe\npublish_async\npublish","category":"page"},{"location":"api/interface/#MQTTClient.MakeConnection","page":"Interfacing Functions","title":"MQTTClient.MakeConnection","text":"MakeConnection(host::Union{IPAddr, String}, port::Int64;\n               ping_timeout=UInt64(60),\n               keep_alive::Int64=32,\n               client_id::String=randstring(8),\n               user::User=User(\"\", \"\"),\n               will::Message=Message(false, 0x00, false, \"\", UInt8[]),\n               clean_session::Bool=true)::Tuple\n\nMakeConnection(path::String;\n               ping_timeout=UInt64(60),\n               keep_alive::Int64=32,\n               client_id::String=randstring(8),\n               user::User=User(\"\", \"\"),\n               will::Message=Message(false, 0x00, false, \"\", UInt8[]),\n               clean_session::Bool=true)::Tuple\n\nMakeConnection(io::T;\n               ping_timeout=UInt64(60),\n               keep_alive::Int64=32,\n               client_id::String=randstring(8),\n               user::User=User(\"\", \"\"),\n               will::Message=Message(false, 0x00, false, \"\", UInt8[]),\n               clean_session::Bool=true)::Tuple where {T <: AbstractIOConnection}\n\nCreates an MQTT client connection to an MQTT broker, handling the construction  of both the Client and MQTTConnection objects. This function provides  flexible ways to specify the connection details either through a TCP connection  with host and port, a Unix Domain Socket path.\n\nArguments\n\nhost::Union{IPAddr, String}: The IP address or hostname of the MQTT broker.\nport::Int64: The port number to connect to.\npath::String: The file system path for Unix Domain Socket connection.\nio::T: An object of subtype AbstractIOConnection.\nping_timeout::UInt64: The ping timeout in seconds (default: 60).\nkeep_alive::Int64: The keep-alive time in seconds (default: 32).\nclient_id::String: The client identifier (default: a random string of length 8).\nuser::User: The user credentials for the MQTT broker (default: anonymous user).\nwill::Message: The last will message to be sent in case of unexpected disconnection (default: an empty will message).\nclean_session::Bool: Indicates whether to start a clean session (default: true).\n\nReturns\n\nA tuple (Client, MQTTConnection) where Client is the MQTT client instance  and MQTTConnection is the connection information used to connect to the broker.\n\nThis function simplifies the process of setting up an MQTT client connection.  Depending on the type of connection, you can specify the broker's IP address  and port, a Unix Domain Socket path, or directly provide any struct that is a subtype of AbstractIOConnection.  It then constructs the necessary Client and MQTTConnection objects with the  provided or default parameters. Refer to the documentation for Client and  MQTTConnection for more details on their fields and usage.\n\nExamples\n\n# Example with IP address and port\nclient, connection = MakeConnection(\"127.0.0.1\", 1883, client_id=\"mqtt_client_1\")\n\n# Example with Unix Domain Socket path\nclient, connection = MakeConnection(\"/var/run/mqtt.sock\", user=User(\"user\", \"pass\"))\n\n# Example with provided connection\ntcp_conn = TCP(Sockets.localhost, 1883)\nclient, connection = MakeConnection(tcp_conn; keep_alive=60, clean_session=false)\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.connect_async","page":"Interfacing Functions","title":"MQTTClient.connect_async","text":"connect_async(client::Client, connection::MQTTConnection)\n\nEstablishes an asynchronous connection to the MQTT broker using the provided Client and MQTTConnection objects. This function initializes the client, establishes the connection, and starts the necessary loops for communication.\n\nArguments\n\nclient::Client: The MQTT client instance.\nconnection::MQTTConnection: The connection information used to connect to the broker.\n\nReturns\n\nA Future object that can be used to await the completion of the connection process.\n\nExample\n\nclient, connection = MakeConnection(\"127.0.0.1\", 1883, client_id=\"mqtt_client_1\")\nfuture = connect_async(client, connection)\nwait(future)\n\nSee Also\n\nconnect: The synchronous version of this function.\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#Sockets.connect","page":"Interfacing Functions","title":"Sockets.connect","text":"connect(protocol::UDS) -> PipeEndpoint\n\nEstablishes a connection to a Unix domain socket at the given path specified in the UDS struct.\n\n\n\n\n\nconnect(protocol::TCP) -> TCPSocket\n\nEstablishes a TCP connection to the given IP address and port specified in the TCP struct.\n\n\n\n\n\nconnect(protocol::MockIOConnection) -> IOBuffer\n\nMocks a connection to an MQTT Broker with a local IOBuffer. Should only be used for testing.\n\n\n\n\n\nconnect(client::Client, connection::MQTTConnection)\n\nEstablishes a synchronous connection to the MQTT broker using the provided Client and MQTTConnection objects. This function wraps connect_async and waits for the connection process to complete.\n\nArguments\n\nclient::Client: The MQTT client instance.\nconnection::MQTTConnection: The connection information used to connect to the broker.\n\nReturns\n\nThe result of the connection process after it completes.\n\nThe connect function is responsible for establishing a connection between an MQTT client and an MQTT broker. It initializes the client's state, sets up the necessary communication channels, and handles the connection handshake according to the MQTT protocol. When called, connect first ensures that the client's state and resources are properly initialized. This includes resetting the client's state, setting up the socket connection, and creating the channels and locks required for communication. The function then starts the asynchronous tasks needed to manage the read, write, and keep-alive loops, which are crucial for maintaining the connection and ensuring that messages are sent and received properly.\n\nAdditionally, the connect function handles the specifics of the MQTT protocol handshake. It constructs and sends the CONNECT packet, including details such as the client ID, user credentials, and optional will message. This handshake process ensures that the broker recognizes the client and sets up the session according to the specified parameters. The synchronous connect function blocks until the connection process is complete, providing a straightforward way to establish the connection without needing to manage asynchronous operations directly. This makes it suitable for applications that require a simple, blocking call to connect to the broker and start communicating immediately.\n\nExample\n\nclient, connection = MakeConnection(\"127.0.0.1\", 1883, client_id=\"mqtt_client_1\")\nresult = connect(client, connection)\n\nSee Also\n\nconnect_async: The asynchronous version of this function.\nClient\nMQTTConnection\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.disconnect","page":"Interfacing Functions","title":"MQTTClient.disconnect","text":"disconnect(client::Client)\n\nDisconnects the client from the broker and stops the tasks.\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.subscribe_async","page":"Interfacing Functions","title":"MQTTClient.subscribe_async","text":"subscribe_async(client::Client, topic::String, on_msg::Function; qos::UInt8=QOS_0)\n\nSubscribe to a topic asynchronously.\n\nArguments\n\nclient::Client: The MQTT client.\ntopic::String: The topic to subscribe to.\non_msg::Function: The function to call when a message is received on the topic.\nqos::UInt8: The quality of service level to use for the subscription. Default is 0.\n\nReturns\n\nFuture: A future that can be used to wait for the subscription to complete.\n\nExamples\n\nfuture = subscribe_async(client, \"my/topic\", on_msg, qos=QOS_2)\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.subscribe","page":"Interfacing Functions","title":"MQTTClient.subscribe","text":"subscribe(client::Client, topic::String, on_msg::Function; qos::UInt8=QOS_0)\n\nSubscribe to a topic.\n\nArguments\n\nclient::Client: The MQTT client.\ntopic::String: The topic to subscribe to.\non_msg::Function: The function to call when a message is received on the topic.\nqos::UInt8: The quality of service level to use for the subscription. Default is 0.\n\nExamples\n\nsubscribe(client, \"my/topic\", on_msg)\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.unsubscribe_async","page":"Interfacing Functions","title":"MQTTClient.unsubscribe_async","text":"unsubscribe_async(client::Client, topics::String...)\n\nUnsubscribes the Client instance from the supplied topic names. Deletes the callback from the client Returns a Future object that contains nothing on success and an exception on failure. \n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.unsubscribe","page":"Interfacing Functions","title":"MQTTClient.unsubscribe","text":"unsubscribe(client::Client, topics::String...)\n\nUnsubscribes the Client instance from the supplied topic names. Waits until the unsubscribe is fully acknowledged. Returns nothing on success and an exception on failure.\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.publish_async","page":"Interfacing Functions","title":"MQTTClient.publish_async","text":"publish_async(client::Client, message::Message)\n\nPublishes the message. Returns a Future object that contains nothing on success and an exception on failure. \n\n\n\n\n\npublish_async(client::Client, topic::String, payload...;\n   dup::Bool=false,\n   qos::QOS=QOS_0,\n   retain::Bool=false)\n\nPulishes a message with the specified parameters. Returns a Future object that contains nothing on success and an exception on failure.  \n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.publish","page":"Interfacing Functions","title":"MQTTClient.publish","text":"publish(client::Client, topic::String, payload...;      dup::Bool=false,      qos::QOS=QOS_0,      retain::Bool=false)\n\nWaits until the publish is completely acknowledged. Publishes a message with the specified parameters. Returns nothign on success and throws an exception on failure.\n\n\n\n\n\n","category":"function"},{"location":"#MQTTClient.jl-Documentation","page":"Home","title":"MQTTClient.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for MQTTClient.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is a client for a client for a MQTT Network.","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"getting-started.md\",\n  \"interface.md\",\n  \"client.md\",\n  \"api/client.md\",\n  \"api/handlers.md\",\n  \"api/interface.md\",\n  \"utils.md\"\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"MQTTClient.resolve\nMQTTClient.topic_eq","category":"page"},{"location":"utils/#MQTTClient.resolve","page":"Utils","title":"MQTTClient.resolve","text":"resolve(future)\n\nFetch the result of a Future object and return it. If the result is an exception, throw the exception, otherwise return the result.\n\nArguments\n\nfuture: The Future object to fetch the result from.\n\nReturns\n\nThe result of the Future, or throws an exception if the result is an exception.\n\n\n\n\n\n","category":"function"},{"location":"utils/#MQTTClient.topic_eq","page":"Utils","title":"MQTTClient.topic_eq","text":"topic_eq(baseT::String, compareT::String)\n\nA function that compares two MQTT topics and returns a boolean value based on their equality. If the baseT topic contains a wildcard character #, the macro checks if the compareT topic contains the string before the wildcard character. Otherwise, it checks if the two topics are equal.\n\nExamples\n\njulia> topic_eq(\"sport/#\", \"sport/tennis\")\ntrue\n\njulia> topic_eq(\"sport/tennis\", \"sport/football\")\nfalse\n\n\n\n\n\n","category":"function"}]
}
