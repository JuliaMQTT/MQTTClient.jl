var documenterSearchIndex = {"docs":
[{"location":"api/client/","page":"Client","title":"Client","text":"Client\nMQTTConnection\nIOConnection\nTCP\nUDS\nMQTTException\nAbstractIOConnection\nPacket\nMessage\nUser\nwrite_loop\nread_loop\nkeep_alive_loop\npacket_id\nwrite_packet","category":"page"},{"location":"api/client/#MQTTClient.Client","page":"Client","title":"MQTTClient.Client","text":"Client\n\nA mutable struct representing an MQTT client.\n\nAn MQTT client is any device (from a microcontroller up to a fully-fledged server) that runs an MQTT library and connects to an MQTT broker over a network. Information is organized in a hierarchy of topics.\n\nFields\n\non_msg::Dict{String,Function}: A dictionary mapping topic names to callback functions.\nkeep_alive::UInt16: The keep-alive time in seconds.\nlast_id::UInt16: The last packet identifier used.\nin_flight::Dict{UInt16, Future}: A dictionary mapping packet identifiers to futures.\nwrite_packets::AbstractChannel: A channel for writing packets.\nsocket: The socket used for communication with the broker.\nsocket_lock: A lock for synchronizing access to the socket.\nping_timeout::UInt64: The ping timeout in seconds.\nping_outstanding::Atomic{UInt8}: An atomic counter for the number of outstanding ping requests.\nlast_sent::Atomic{Float64}: An atomic float representing the timestamp of the last sent packet.\nlast_received::Atomic{Float64}: An atomic float representing the timestamp of the last received packet.\n\nConstructor\n\nClient(ping_timeout::UInt64=UInt64(60)) constructs a new Client object with the specified ping timeout (default: 60 seconds).\n\n\n\n\n\n","category":"type"},{"location":"api/client/#MQTTClient.MQTTConnection","page":"Client","title":"MQTTClient.MQTTConnection","text":"MQTTConnection{T <: AbstractIOConnection}\n\nA struct containing an MQTT connection's metadata.\n\nFields\n\nprotocol::T: The underlying IO connection.\nkeep_alive::Int64: The keep-alive time in seconds.\nclient_id::String: The client identifier.\nuser::User: The user credentials.\nwill::Message: The last will and testament message.\nclean_session::Bool: Whether to start a clean session.\n\nConstructors\n\nMQTTConnection(protocol::T;         keep_alive::Int64=32,         client_id::String=randstring(8),         user::User=User(\"\", \"\"),         will::Message=Message(false, 0x00, false, \"\", UInt8[]),         clean_session::Bool=true) where T <: AbstractIOConnection constructs a new MQTTConnection object with the specified protocol and optional keyword arguments.\n\nMQTTConnection(protocol::T,         keep_alive::Int64,         client_id::String,         user::User,         will::Message,         clean_session::Bool) where T <: AbstractIOConnection constructs a new MQTTConnection object with the specified arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/client/#MQTTClient.IOConnection","page":"Client","title":"MQTTClient.IOConnection","text":"IOConnection(ip::IPAddr, port::Int64)\n\nConstructs a new TCP object with the specified IP address and port number.\n\nArguments\n\nip::IPAddr: The IP address of the remote host.\nport::Int64: The port number on the remote host.\n\nReturns\n\nTCP: A new TCP object.\n\n\n\nIOConnection(ip::String, port::Int64)\n\nConstructs a new TCP object with the specified IP address and port number.\n\nArguments\n\nip::String: The IP address of the remote host as a string.\nport::Int64: The port number on the remote host.\n\nReturns\n\nTCP: A new TCP object.\n\n\n\nIOConnection(path::AbstractString)\n\nConstructs a new UDS object with the specified file system path.\n\nArguments\n\npath::AbstractString: The file system path of the socket.\n\nReturns\n\nUDS: A new UDS object.\n\n\n\n\n\n","category":"function"},{"location":"api/client/#MQTTClient.MQTTException","page":"Client","title":"MQTTClient.MQTTException","text":"struct MQTTException <: Exception\n    msg::AbstractString\nend\n\nA custom exception type for MQTT errors.\n\n# Examples\n```julia\njulia> throw(MQTTException(\"Connection refused: Not authorized\"))\nMQTTException(\"Connection refused: Not authorized\")\n```\n\n\n\n\n\n","category":"type"},{"location":"api/client/#MQTTClient.User","page":"Client","title":"MQTTClient.User","text":"User(name::String, password::String)\n\nA struct that represents a user with a name and password.\n\nExamples\n\njulia> user = User(\"John\", \"password\")\nUser(\"John\", \"password\")\n\n\n\n\n\n","category":"type"},{"location":"client/#Client-struct","page":"MQTT Client","title":"Client struct","text":"","category":"section"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"The client struct is used to store state for an MQTT connection. All callbacks, apart from on_message, can't be set through the constructor and have to be set manually after instantiating the Client struct.","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"Fields in the Client that are relevant for the library user:","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"ping_timeout::UInt64: Time, in seconds, the Client waits for the PINGRESP after sending a PINGREQ before he disconnects ; default = 60 seconds\non_message::Function: This function gets called upon receiving a publish message from the broker.\non_disconnect::Function:\non_connect::Function:\non_subscribe::Function:\non_unsubscribe::Function:","category":"page"},{"location":"client/#Constructors","page":"MQTT Client","title":"Constructors","text":"","category":"section"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"Client()","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"Specify a custom ping_timeout","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"Client(ping_timeout::UInt64 = 700)","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"Use the wrapping function to get the client and the connection metadata struct. this is equivalent to using the Client constructor; but with more specific syntax. passing a single unix path or a ip and a port here will determine which protocol is used to communication.","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"client, connection = MakeConnection()","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"additional information can be specified for when the connection is made.","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"client, connection = MakeConnection(\"/tmp/mqtt.sock\", keep_alive=60, client_id=\"TestClient\", user=User(\"name\", \"pw\"), will=Message(QOS_2, \"TestClient/will\", \"payload\", more_payload_data))\n\n## Message struct\nThe `Message` struct is the data structure for generic MQTT messages. This is mostly used internally but is exposed to the user in some cases for easier to read arguments (Passing a \"will\" to the connect method uses the `Message` struct for example).\n\n#### Constructors\nThis is a reduced constructor meant for messages that can't be duplicate or retained (like the \"will\"). **This message constructor should be in most cases!** The dup and retained flag are false by default.\n","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"julia function Message(qos::QOS, topic::String, payload...)","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"\nThis is the full `Message` constructor. It has all possible fields.\n","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"julia function Message(dup::Bool, qos::QOS, retain::Bool, topic::String, payload...)","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"\nThis constructor is mostly for internal use. It uses the `UInt8` equivalent of the `QOS` enum for easier processing.\n","category":"page"},{"location":"client/","page":"MQTT Client","title":"MQTT Client","text":"julia function Message(dup::Bool, qos::UInt8, retain::Bool, topic::String, payload...) ```","category":"page"},{"location":"getting-started/#MQTTClient","page":"Getting Started","title":"MQTTClient","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Documentation for MQTTClient.","category":"page"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Pkg.add(\"MQTTClient\")","category":"page"},{"location":"getting-started/#Testing","page":"Getting Started","title":"Testing","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Pkg.test(\"MQTTClient\")","category":"page"},{"location":"getting-started/#Usage","page":"Getting Started","title":"Usage","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Import the library with the using keyword.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Samples are available in the examples directory.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using MQTTClient","category":"page"},{"location":"getting-started/#Advanced-Usage","page":"Getting Started","title":"Advanced Usage","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The readloop, _writeloop_ keepaliveloop, and onmsg_ callback are all called as async processes via @async.","category":"page"},{"location":"getting-started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"To use this library you need to follow at least these steps:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Create an MQTTConnection struct for a given broker and protocol.\nCreate an instance of the Client struct.\nCall the connect method with your Client and MQTTConnection instance.\nExchange data with the broker through publish, subscribe and unsubscribe. When subscribing, pass your on_msg function for that topic.\nDisconnect from the broker. (Not strictly necessary, if you don't want to resume the session but considered good form and less likely to crash).","category":"page"},{"location":"getting-started/#Basic-example","page":"Getting Started","title":"Basic example","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Refer to the corresponding method documentation to find more options.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using MQTTClient\nbroker = \"test.mosquitto.org\"\n\n#Define the callback for receiving messages.\nfunction on_msg(topic, payload)\n    info(\"Received message topic: [\", topic, \"] payload: [\", String(payload), \"]\")\nend\n\n#Instantiate a client and connection.\nclient, connection = MakeConnection(broker, 1883)\nconnect(client, connection)\n#Set retain to true so we can receive a message from the broker once we subscribe\n#to this topic.\npublish(client, \"jlExample\", \"Hello World!\", retain=true)\n#Subscribe to the topic we sent a retained message to.\nsubscribe(client, \"jlExample\", on_msg, qos=QOS_1))\n#Unsubscribe from the topic\nunsubscribe(client, \"jlExample\")\n#Disconnect from the broker. Not strictly needed as the broker will also\n#disconnect us if the socket is closed. But this is considered good form\n#and needed if you want to resume this session later.\ndisconnect(client)","category":"page"},{"location":"getting-started/#Internal-workings","page":"Getting Started","title":"Internal workings","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"It isn't necessary to read this section if you just want to use this library but it might give additional insight into how everything works.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The Client instance has a Channel, called write_packets, to keep track of outbound messages that still need to be sent. Julia channels are basically just blocking queues so they have exactly the behavior we want.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For storing messages that are awaiting acknowledgment, Client has a Dict, mapping message ids to Future instances. These futures get completed once the message has been completely acknowledged. There might then be information in the Future relevant to the specific message.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Once the connect method is called on a Client, relevant fields are initialized and the julia connect method is called to get a connected socket. Then two background tasks are started that perpetually check for messages to send and receive. If keep_alive is non-zero another tasks get started that handles sending the keep alive and verifying the pingresp arrived in time.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"TODO explain read and write loop a bit","category":"page"},{"location":"interfaces/#Connect","page":"MQTT Interface Functions","title":"Connect","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"MQTT v3.1.1 Doc","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Connects the Client instance to the specified broker. There is a synchronous and an asynchronous version available. Both versions take the same arguments.","category":"page"},{"location":"interfaces/#Arguments","page":"MQTT Interface Functions","title":"Arguments","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Required arguments:","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"client::Client: The client to connect to the broker.\nhost::AbstractString: The hostname or ip address of the broker.","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Optional arguments:","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"port::Integer: The port to use ; default = 1883\nkeep_alive::Int64: If the client hasn't sent or received a message within this time limit, it will ping the broker to verify the connection is still active. A value of 0 means no pings will be sent. ; default = 0\nclient_id::String: The id of the client. This should be unique per broker. Some brokers allow an empty clientid for a stateless connection (this means cleansession needs to be true). ; default = random 8 char string\nuser::User: The user, password pair for authentication with the broker. Password can be empty even if user isn't. The password should probably be encrypted. ; default = empty pair  \nwill::Message: The will of this client. This message gets published on the specified topic once the client disconnects from the broker. The type of this argument is Message, consult with it's documentation above for more info. ; default = empty will\nclean_session::Bool: Specifies whether or not a connection should be resumed. This implies this Client instance was previously connected to this broker. ; default = true","category":"page"},{"location":"interfaces/#Call-example","page":"MQTT Interface Functions","title":"Call example","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"The dup and retain flag of a will have to be false so it's safest to use the minimal Message constructor (Refer to Message documentation above).","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"connect(client, connection)","category":"page"},{"location":"interfaces/#Synchronous-connect","page":"MQTT Interface Functions","title":"Synchronous connect","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method waits until the client is connected to the broker. TODO add return documentation","category":"page"},{"location":"interfaces/#Asynchronous-connect","page":"MQTT Interface Functions","title":"Asynchronous connect","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method doesn't wait and returns a Future object. You may wait on this object with the fetch method. This future completes once the client is fully connected. TODO add future data documentation","category":"page"},{"location":"interfaces/#Publish","page":"MQTT Interface Functions","title":"Publish","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"MQTT v3.1.1 Doc","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Publishes a message to the broker connected to the Client instance provided as a parameter. There is a synchronous and an asynchronous version available. Both versions take the same arguments.","category":"page"},{"location":"interfaces/#Arguments-2","page":"MQTT Interface Functions","title":"Arguments","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Required arguments:","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"client::Client: The client to send the message over.\ntopic::String: The topic to publish on. Normal rules for publish topics apply so \"/ are allowed but no wildcards.\npayload::Any...: Can be several parameters with potentially different types. Can also be empty.","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Optional arguments:","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"dup::Bool: Tells the broker that the message is a duplicate. This should not be used under normal circumstances as the library handles this. ; default = false\nqos::QOS: The MQTT quality of service to use for the message. This has to be a QOS constant (QOS0, QOS1, QOS2). ; *default = QOS0*\nretain::Bool: Whether or not the message should be retained by the broker. This means the broker sends it to all clients who subscribe to this topic ; default = false","category":"page"},{"location":"interfaces/#Call-example-2","page":"MQTT Interface Functions","title":"Call example","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"These are valid payload... examples.","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"publish(c, \"hello/world\")\npublish(c, \"hello/world\", \"Test\", 6, 4.2)","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This is a valid use of the optional arguments.","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"publish(c, \"hello/world\", \"Test\", 6, 4.2, qos=QOS_1, retain=true)","category":"page"},{"location":"interfaces/#Synchronous-publish","page":"MQTT Interface Functions","title":"Synchronous publish","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method waits until the publish message has been processed completely and successfully. So in case of QOS 2 it waits until the PUBCOMP has been received. TODO add return documentation","category":"page"},{"location":"interfaces/#Asynchronous-publish","page":"MQTT Interface Functions","title":"Asynchronous publish","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method doesn't wait and returns a Future object. You may choose to wait on this object. This future completes once the publish message has been processed completely and successfully. So in case of QOS 2 it waits until the PUBCOMP has been received. TODO change future data documentation","category":"page"},{"location":"interfaces/#Subscribe","page":"MQTT Interface Functions","title":"Subscribe","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"MQTT v3.1.1 Doc","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Subscribes the Client instance, provided as a parameter, to the specified topics. There is a synchronous and an asynchronous version available. Both versions take the same arguments.","category":"page"},{"location":"interfaces/#Arguments-3","page":"MQTT Interface Functions","title":"Arguments","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Required arguments:","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"client::Client: The connected client to subscribe on. TODO phrasing?\ntopic::String: The name of the topic.\non_msg::Function: the callback function for that topic.\nqos::QOS: the named argument to set the QOS, defaults to QOS_0.","category":"page"},{"location":"interfaces/#Call-example-3","page":"MQTT Interface Functions","title":"Call example","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This example subscribes to the topic \"test\" with QOS2 and \"test2\" with QOS0.","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"subscribe(c, \"test\", ((t,p)->do_a_thing(p)), qos=QOS_2))","category":"page"},{"location":"interfaces/#Synchronous-subscribe","page":"MQTT Interface Functions","title":"Synchronous subscribe","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method waits until the subscribe message has been successfully sent and acknowledged. TODO add return documentation","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"subscribe(c, \"test\", on_msg, qos=QOS_2))","category":"page"},{"location":"interfaces/#Asynchronous-subscribe","page":"MQTT Interface Functions","title":"Asynchronous subscribe","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method doesn't wait and returns a Future object. You may choose to wait on this object. This future completes once the subscribe message has been successfully sent and acknowledged. TODO change future data documentation","category":"page"},{"location":"interfaces/#Unsubscribe","page":"MQTT Interface Functions","title":"Unsubscribe","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"MQTT v3.1.1 Doc","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method unsubscribes the Client instance from the specified topics. There is a synchronous and an asynchronous version available. Both versions take the same arguments.","category":"page"},{"location":"interfaces/#Arguments-4","page":"MQTT Interface Functions","title":"Arguments","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Required arguments:","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"client::Client: The connected client to unsubscribe from the topics.\ntopics::String...: The Tuple of topics to unsubscribe from.","category":"page"},{"location":"interfaces/#Example-call","page":"MQTT Interface Functions","title":"Example call","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"unsubscribe(c, \"test1\", \"test2\", \"test3\")","category":"page"},{"location":"interfaces/#Synchronous-unsubscribe","page":"MQTT Interface Functions","title":"Synchronous unsubscribe","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method waits until the unsubscribe method has been sent and acknowledged. TODO add return documentation","category":"page"},{"location":"interfaces/#Asynchronous-unsubscribe","page":"MQTT Interface Functions","title":"Asynchronous unsubscribe","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"This method doesn't wait and returns a Future object. You may wait on this object with the fetch method. This future completes once the unsubscribe message has been sent and acknowledged. TODO add future data documentation","category":"page"},{"location":"interfaces/#Disconnect","page":"MQTT Interface Functions","title":"Disconnect","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"MQTT v3.1.1 Doc","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Disconnects the Client instance gracefully, shuts down the background tasks and stores session state. There is only a synchronous version available.","category":"page"},{"location":"interfaces/#Arguments-5","page":"MQTT Interface Functions","title":"Arguments","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"Required arguments:","category":"page"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"client::Client: The client to disconnect.","category":"page"},{"location":"interfaces/#Example-call-2","page":"MQTT Interface Functions","title":"Example call","text":"","category":"section"},{"location":"interfaces/","page":"MQTT Interface Functions","title":"MQTT Interface Functions","text":"disconnect(c)","category":"page"},{"location":"api/interface/","page":"Interfacing Functions","title":"Interfacing Functions","text":"MakeConnection\nconnect_async\nconnect\ndisconnect\nsubscribe_async\nsubscribe\nunsubscribe_async\nunsubscribe\npublish_async\npublish","category":"page"},{"location":"api/interface/#MQTTClient.MakeConnection","page":"Interfacing Functions","title":"MQTTClient.MakeConnection","text":"MakeConnection(host::Union{IPAddr, String}, port::Int64;\n    ping_timeout=UInt64(60),\n    keep_alive::Int64=32,\n    client_id::String=randstring(8),\n    user::User=User(\"\", \"\"),\n    will::Message=Message(false, 0x00, false, \"\", UInt8[]),\n    clean_session::Bool=true) -> Tuple{Client, MQTTConnection}\n\nEstablishes a connection to the given host and port. The host can be either an IP address or a hostname.\n\nArguments\n\nhost: The IP address or hostname to connect to.\nport: The port number to connect to.\nping_timeout: The maximum time in seconds to wait for a ping response before considering the connection lost.\nkeep_alive: The maximum time in seconds that the client should wait before sending a ping request to keep the connection alive.\nclient_id: The client identifier string.\nuser: The user credentials for authentication.\nwill: The last will and testament message to be sent by the server on behalf of the client.\nclean_session: Whether to start a clean session or resume a previous one.\n\nReturns\n\nA tuple containing a Client object and an MQTTConnection object.\n\n\n\n\n\nMakeConnection(path::String;\n    ping_timeout=UInt64(60),\n    keep_alive::Int64=32,\n    client_id::String=randstring(8),\n    user::User=User(\"\", \"\"),\n    will::Message=Message(false, 0x00, false, \"\", UInt8[]),\n    clean_session::Bool=true)  -> Tuple{Client, MQTTConnection}\n\nEstablishes a connection to a Unix domain socket at the given path.\n\nArguments\n\npath: The path of the Unix domain socket to connect to.\nping_timeout: The maximum time in seconds to wait for a ping response before considering the connection lost.\nkeep_alive: The maximum time in seconds that the client should wait before sending a ping request to keep the connection alive.\nclient_id: The client identifier string.\nuser: The user credentials for authentication.\nwill: The last will and testament message to be sent by the server on behalf of the client.\nclean_session: Whether to start a clean session or resume a previous one.\n\nReturns\n\nA tuple containing a Client object and an MQTTConnection object.\n\n\n\n\n\nMakeConnection(io::T,\n    ping_timeout=UInt64(60),\n    keep_alive::Int64=32,\n    client_id::String=randstring(8),\n    user::User=User(\"\", \"\"),\n    will::Message=Message(false, 0x00, false, \"\", UInt8[]),\n    clean_session::Bool=true)  -> Tuple{Client, MQTTConnection}\n\nEstablishes an MQTT connection using the given IO connection.\n\nArguments\n\nio: An IO connection object that implements the AbstractIOConnection interface.\nping_timeout: The maximum time in seconds to wait for a ping response before considering the connection lost.\nkeep_alive: The maximum time in seconds that the client should wait before sending a ping request to keep the connection alive.\nclient_id: The client identifier string.\nuser: The user credentials for authentication.\nwill: The last will and testament message to be sent by the server on behalf of the client.\nclean_session: Whether to start a clean session or resume a previous one.\n\nReturns\n\nA tuple containing a Client object and an MQTTConnection object.\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.connect_async","page":"Interfacing Functions","title":"MQTTClient.connect_async","text":"connect_async(client::Client, connection::MQTTConnection)\n\nEstablishes an asynchronous connection to an MQTT broker using the specified client and connection objects.\n\nThe function sets up the write and read loops, as well as the keep-alive loop if the keep-alive time is greater than 0. It also sets the protocol name and level, and the connect flags.\n\nIf the user name and password are provided in the connection object, they are included in the connect flags. If a will topic is provided, it is also included in the connect flags.\n\nThe function returns a Future object that can be used to track the progress of the connection.\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#Sockets.connect","page":"Interfacing Functions","title":"Sockets.connect","text":"connect(protocol::UDS) -> PipeEndpoint\n\nEstablishes a connection to a Unix domain socket at the given path specified in the UDS struct.\n\n\n\n\n\nconnect(protocol::TCP) -> TCPSocket\n\nEstablishes a TCP connection to the given IP address and port specified in the TCP struct.\n\n\n\n\n\nconnect(client::Client, connection::MQTTConnection)\n\nEstablishes a synchronous connection to an MQTT broker using the specified client and connection objects.\n\nThis function is a wrapper around the connect_async function, which establishes an asynchronous connection. The connect function blocks until the connection is established by calling the resolve function on the Future object returned by connect_async.\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.disconnect","page":"Interfacing Functions","title":"MQTTClient.disconnect","text":"disconnect(client::Client)\n\nDisconnects the client from the broker and stops the tasks.\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.subscribe_async","page":"Interfacing Functions","title":"MQTTClient.subscribe_async","text":"subscribe_async(client::Client, topic::String, on_msg::Function; qos::UInt8=QOS_0)\n\nSubscribe to a topic asynchronously.\n\nArguments\n\nclient::Client: The MQTT client.\ntopic::String: The topic to subscribe to.\non_msg::Function: The function to call when a message is received on the topic.\nqos::UInt8: The quality of service level to use for the subscription. Default is 0.\n\nReturns\n\nFuture: A future that can be used to wait for the subscription to complete.\n\nExamples\n\nfuture = subscribe_async(client, \"my/topic\", on_msg, qos=QOS_2)\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.subscribe","page":"Interfacing Functions","title":"MQTTClient.subscribe","text":"subscribe(client::Client, topic::String, on_msg::Function; qos::UInt8=QOS_0)\n\nSubscribe to a topic.\n\nArguments\n\nclient::Client: The MQTT client.\ntopic::String: The topic to subscribe to.\non_msg::Function: The function to call when a message is received on the topic.\nqos::UInt8: The quality of service level to use for the subscription. Default is 0.\n\nExamples\n\nsubscribe(client, \"my/topic\", on_msg)\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.unsubscribe_async","page":"Interfacing Functions","title":"MQTTClient.unsubscribe_async","text":"unsubscribe_async(client::Client, topics::String...)\n\nUnsubscribes the Client instance from the supplied topic names. Deletes the callback from the client Returns a Future object that contains nothing on success and an exception on failure. \n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.unsubscribe","page":"Interfacing Functions","title":"MQTTClient.unsubscribe","text":"unsubscribe(client::Client, topics::String...)\n\nUnsubscribes the Client instance from the supplied topic names. Waits until the unsubscribe is fully acknowledged. Returns nothing on success and an exception on failure.\n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.publish_async","page":"Interfacing Functions","title":"MQTTClient.publish_async","text":"publish_async(client::Client, message::Message)\n\nPublishes the message. Returns a Future object that contains nothing on success and an exception on failure. \n\n\n\n\n\npublish_async(client::Client, topic::String, payload...;\n   dup::Bool=false,\n   qos::QOS=QOS_0,\n   retain::Bool=false)\n\nPulishes a message with the specified parameters. Returns a Future object that contains nothing on success and an exception on failure.  \n\n\n\n\n\n","category":"function"},{"location":"api/interface/#MQTTClient.publish","page":"Interfacing Functions","title":"MQTTClient.publish","text":"publish(client::Client, topic::String, payload...;      dup::Bool=false,      qos::QOS=QOS_0,      retain::Bool=false)\n\nWaits until the publish is completely acknowledged. Publishes a message with the specified parameters. Returns nothign on success and throws an exception on failure.\n\n\n\n\n\n","category":"function"},{"location":"api/handlers/","page":"Internal Functions","title":"Internal Functions","text":"handle_connack\nhandle_publish\nhandle_pubrec\nhandle_pubrel\nhandle_suback\nhandle_pingresp","category":"page"},{"location":"#MQTTClient.jl-Documentation","page":"Home","title":"MQTTClient.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for MQTTClient.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is a client for a client for a MQTT Network.","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"getting-started.md\",\n  \"interface.md\",\n  \"client.md\",\n  \"api/client.md\",\n  \"api/handlers.md\",\n  \"api/interface.md\",\n  \"utils.md\"\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"mqtt_channel\ntopic_eq\nmqtt_read\nmqtt_write\nwrite_len\nread_len\nresolve\nfilter_wildcard_len_check\ntopic_wildcard_len_check","category":"page"}]
}
