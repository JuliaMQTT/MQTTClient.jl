var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MQTTClient","category":"page"},{"location":"#MQTTClient","page":"Home","title":"MQTTClient","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MQTTClient.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MQTTClient]","category":"page"},{"location":"#MQTTClient.Client","page":"Home","title":"MQTTClient.Client","text":"Client([ping_timeout::UInt64])\n\nA mutable struct that represents an MQTT client.\n\nArguments\n\nping_timeout::UInt64: The number of seconds to wait for a ping response before disconnecting. Default is 60.\n\nFields\n\non_msg::Dict{String,Function}: A dictionary of functions that will be called when a message is received.\nkeep_alive::UInt16: The number of seconds between pings.\nlast_id::UInt16: The last message ID used.\nin_flight::Dict{UInt16, Future}: A dictionary of messages that are waiting for a response.\nwrite_packets::AbstractChannel: A channel for writing packets to the socket.\nsocket: The socket used for communication.\nsocket_lock: A lock for the socket.\nping_timeout::UInt64: The number of seconds to wait for a ping response before disconnecting.\nping_outstanding::Atomic{UInt8}: A flag indicating whether a ping has been sent but not yet received.\nlast_sent::Atomic{Float64}: The time the last packet was sent.\nlast_received::Atomic{Float64}: The time the last packet was received.\n\nExamples\n\njulia> client = Client()\n\n\n\n\n\n","category":"type"},{"location":"#MQTTClient.MQTTException","page":"Home","title":"MQTTClient.MQTTException","text":"struct MQTTException <: Exception\n    msg::AbstractString\nend\n\nA custom exception type for MQTT errors.\n\n# Examples\n```julia-repl\njulia> throw(MQTTException(\"Connection refused: Not authorized\"))\nMQTTException(\"Connection refused: Not authorized\")\n```\n\n\n\n\n\n","category":"type"},{"location":"#MQTTClient.Message","page":"Home","title":"MQTTClient.Message","text":"Message\n\nA composite type representing a message.\n\nFields\n\ndup::Bool: a boolean indicating whether the message is a duplicate.\nqos::UInt8: an 8-bit unsigned integer representing the quality of service.\nretain::Bool: a boolean indicating whether the message should be retained.\ntopic::String: a string representing the topic.\npayload::Array{UInt8}: an array of 8-bit unsigned integers representing the payload.\n\nConstructors\n\nMessage(qos::QOS, topic::String, payload...): constructs a new message with default values for dup and retain.\nMessage(dup::Bool, qos::QOS, retain::Bool, topic::String, payload...): constructs a new message with all fields specified.\nMessage(dup::Bool, qos::UInt8, retain::Bool, topic::String, payload...): constructs a new message with all fields specified.\n\n\n\n\n\n","category":"type"},{"location":"#MQTTClient.Packet","page":"Home","title":"MQTTClient.Packet","text":"Packet\n\nA composite type representing a packet.\n\nFields\n\ncmd::UInt8: an 8-bit unsigned integer representing the command.\ndata::Any: any value representing the data.\n\n\n\n\n\n","category":"type"},{"location":"#MQTTClient.User","page":"Home","title":"MQTTClient.User","text":"User(name::String, password::String)\n\nA struct that represents a user with a name and password.\n\nExamples\n\njulia> user = User(\"John\", \"password\")\nUser(\"John\", \"password\")\n\n\n\n\n\n","category":"type"},{"location":"#MQTTClient.MQTTConnection-Tuple{}","page":"Home","title":"MQTTClient.MQTTConnection","text":"MQTTConnection(;ping_timeout=UInt64(60))\n\nCreate a new Client object with the specified ping_timeout (optional).\n\nKeyword Arguments\n\nping_timeout::UInt64=60: The number of seconds to wait for a ping response before disconnecting. Default is 60.\n\nExamples\n\nclient = MQTTConnection()\nclient = MQTTConnection(ping_timeout=30)\n\n\n\n\n\n","category":"method"},{"location":"#MQTTClient.connect_async","page":"Home","title":"MQTTClient.connect_async","text":"connect_async(client::Client, host::AbstractString, port::Integer=1883;\n   keep_alive::UInt16=0x0000,\n   client_id::String=randstring(8),\n   user::User=User(\"\", \"\"),\n   will::Message=Message(false, 0x00, false, \"\", Array{UInt8}()),\n   clean_session::Bool=true)\n\nConnects the Client instance to the specified broker.  Returns a Future object that contains a session_present bit from the broker on success and an exception on failure.\n\nArguments\n\nkeep_alive::Int64=0: Time in seconds to wait before sending a ping to the broker if no other packets are being sent or received.\nclient_id::String=randstring(8): The id of the client.\nuser::User=User(\"\", \"\"): The MQTT authentication.\nwill::Message=Message(false, 0x00, false, \"\", Array{UInt8}()): The MQTT will to send to all other clients when this client disconnects.  \nclean_session::Bool=true: Flag to resume a session with the broker if present.\n\n\n\n\n\n","category":"function"},{"location":"#MQTTClient.disconnect-Tuple{Client}","page":"Home","title":"MQTTClient.disconnect","text":"disconnect(client::Client)\n\nDisconnects the client from the broker and stops the tasks.\n\n\n\n\n\n","category":"method"},{"location":"#MQTTClient.handle_connack-Tuple{Client, IO, UInt8, UInt8}","page":"Home","title":"MQTTClient.handle_connack","text":"handle_connack(client::Client, s::IO, cmd::UInt8, flags::UInt8)\n\nHandle a CONNACK packet.\n\nArguments\n\nclient::Client: The client that received the packet.\ns::IO: The socket used for communication.\ncmd::UInt8: The command byte.\nflags::UInt8: The flags byte.\n\nExamples\n\njulia> handle_connack(client, s, 0x20, 0x00)\n\n\n\n\n\n","category":"method"},{"location":"#MQTTClient.handle_publish-Tuple{Client, IO, UInt8, UInt8}","page":"Home","title":"MQTTClient.handle_publish","text":"handle_publish(client::Client, s::IO, cmd::UInt8, flags::UInt8)\n\nThis function handles the publish command in MQTT protocol.\n\nArguments\n\nclient: A client object.\ns: An input stream.\ncmd: An unsigned 8-bit integer.\nflags: An unsigned 8-bit integer.\n\nReturns\n\nFuture.\n\n\n\n\n\n","category":"method"},{"location":"#MQTTClient.keep_alive_loop-Tuple{Client}","page":"Home","title":"MQTTClient.keep_alive_loop","text":"keep_alive_loop(client::Client)\n\nThis function runs a loop that sends a PINGREQ message to the MQTT broker to keep the connection alive. The loop checks the connection at regular intervals determined by the client.keep_alive value. If no message has been sent or received within the keep-alive interval, a PINGREQ message is sent. If no PINGRESP message is received within the client.ping_timeout interval, the client is disconnected.\n\n\n\n\n\n","category":"method"},{"location":"#MQTTClient.publish-Tuple{Client, String, Vararg{Any}}","page":"Home","title":"MQTTClient.publish","text":"publish(client::Client, topic::String, payload...;      dup::Bool=false,      qos::QOS=QOS_0,      retain::Bool=false)\n\nWaits until the publish is completely acknowledged. Publishes a message with the specified parameters. Returns nothign on success and throws an exception on failure.\n\n\n\n\n\n","category":"method"},{"location":"#MQTTClient.publish_async-Tuple{Client, MQTTClient.Message}","page":"Home","title":"MQTTClient.publish_async","text":"publish_async(client::Client, message::Message)\n\nPublishes the message. Returns a Future object that contains nothing on success and an exception on failure. \n\n\n\n\n\n","category":"method"},{"location":"#MQTTClient.publish_async-Tuple{Client, String, Vararg{Any}}","page":"Home","title":"MQTTClient.publish_async","text":"publish_async(client::Client, topic::String, payload...;\n   dup::Bool=false,\n   qos::QOS=QOS_0,\n   retain::Bool=false)\n\nPulishes a message with the specified parameters. Returns a Future object that contains nothing on success and an exception on failure.  \n\n\n\n\n\n","category":"method"},{"location":"#MQTTClient.read_loop-Tuple{Any}","page":"Home","title":"MQTTClient.read_loop","text":"read_loop(client)\n\nReads data from a client socket and processes it.\n\nArguments\n\nclient: A client object.\n\nExample\n\nread_loop(client)\n\n\n\n\n\n","category":"method"},{"location":"#MQTTClient.subscribe-Tuple{Any, Any, Any}","page":"Home","title":"MQTTClient.subscribe","text":"subscribe(client::Client, topic::String, on_msg::Function; qos::UInt8=QOS_0)\n\nSubscribe to a topic.\n\nArguments\n\nclient::Client: The MQTT client.\ntopic::String: The topic to subscribe to.\non_msg::Function: The function to call when a message is received on the topic.\nqos::UInt8: The quality of service level to use for the subscription. Default is 0.\n\nExamples\n\nsubscribe(client, \"my/topic\", on_msg)\n\n\n\n\n\n","category":"method"},{"location":"#MQTTClient.subscribe_async-Tuple{Any, Any, Any}","page":"Home","title":"MQTTClient.subscribe_async","text":"subscribe_async(client::Client, topic::String, on_msg::Function; qos::UInt8=QOS_0)\n\nSubscribe to a topic asynchronously.\n\nArguments\n\nclient::Client: The MQTT client.\ntopic::String: The topic to subscribe to.\non_msg::Function: The function to call when a message is received on the topic.\nqos::UInt8: The quality of service level to use for the subscription. Default is 0.\n\nReturns\n\nFuture: A future that can be used to wait for the subscription to complete.\n\nExamples\n\nfuture = subscribe_async(client, \"my/topic\", on_msg, qos=QOS_2)\n\n\n\n\n\n","category":"method"},{"location":"#MQTTClient.unsubscribe-Tuple{Client, Vararg{String}}","page":"Home","title":"MQTTClient.unsubscribe","text":"unsubscribe(client::Client, topics::String...)\n\nUnsubscribes the Client instance from the supplied topic names. Waits until the unsubscribe is fully acknowledged. Returns nothing on success and an exception on failure.\n\n\n\n\n\n","category":"method"},{"location":"#MQTTClient.unsubscribe_async-Tuple{Client, Vararg{String}}","page":"Home","title":"MQTTClient.unsubscribe_async","text":"unsubscribe_async(client::Client, topics::String...)\n\nUnsubscribes the Client instance from the supplied topic names. Deletes the callback from the client Returns a Future object that contains nothing on success and an exception on failure. \n\n\n\n\n\n","category":"method"},{"location":"#MQTTClient.write_loop-Tuple{Any}","page":"Home","title":"MQTTClient.write_loop","text":"write_loop(client)\n\nThis function writes data to the socket.\n\nArguments\n\nclient: A client object.\n\nReturns\n\nNothing.\n\n\n\n\n\n","category":"method"},{"location":"#Sockets.connect","page":"Home","title":"Sockets.connect","text":"connect(client::Client, host::AbstractString, port::Integer=1883;\n    keep_alive::UInt16=0x0000,\n    client_id::String=randstring(8),\n    user::User=User(\"\", \"\"),\n    will::Message=Message(false, 0x00, false, \"\", Array{UInt8}()),\n    clean_session::Bool=true)\n\nConnects the Client instance to the specified broker.  Waits until the connect is done. Returns the session_present bit from the broker on success and an exception on failure.\n\nArguments\n\nkeep_alive::Int64=0: Time in seconds to wait before sending a ping to the broker if no other packets are being sent or received.\nclient_id::String=randstring(8): The id of the client.\nuser::User=User(\"\", \"\"): The MQTT authentication.\nwill::Message=Message(false, 0x00, false, \"\", Array{UInt8}()): The MQTT will to send to all other clients when this client disconnects.  \nclean_session::Bool=true: Flag to resume a session with the broker if present.\n\n\n\n\n\n","category":"function"},{"location":"#MQTTClient.@dispatch-Tuple{Any}","page":"Home","title":"MQTTClient.@dispatch","text":"@dispatch(ex)\n\nA macro that dispatches the execution of an expression ex asynchronously.\n\nIf the number of threads is equal to 1, it uses the @async macro to execute the expression asynchronously.\n\nIf the number of threads is greater than 1, it uses the Dagger.@spawn macro to execute the expression asynchronously.\n\nIf the number of threads is not valid, it throws an exception.\n\nExamples\n\njulia> @dispatch println(\"Hello, World!\")\nTask (done) @0x00007f8c3e8a1010\n\njulia> @dispatch begin\n           sleep(1)\n           println(\"Hello, World!\")\n       end\nTask (done) @0x00007f8c3e8a1010\n\n\n\n\n\n","category":"macro"},{"location":"#MQTTClient.@mqtt_channel","page":"Home","title":"MQTTClient.@mqtt_channel","text":"mqtt_channel(len::Number=128)\n\nA macro that declares a data channel based on the number of threads available. If more than one thread is available, it returns a RemoteChannel with a Channel{Packet} of length len. Otherwise, it returns a Channel{Packet} of length len.\n\nArguments\n\nlen::Number=128: The length of the channel. Defaults to 128.\n\nExamples\n\n@mqtt_channel  # Returns a Channel{Packet} of length 128\n@mqtt_channel 64  # Returns a Channel{Packet} of length 64\n\n\n\n\n\n","category":"macro"}]
}
